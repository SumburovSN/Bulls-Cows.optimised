Правила игры в быки и коровы.
Каждый игрок загадывает 4-значное число из разных цифр.
Соперники пытаются отгадать число оппонента, предлагая 4-значное число, которое также должно состоять из разных цифр. Если цифра в предложенном числе совпадает с загаданным числом, но не совпадает с местом, это называется корова. Если цифра совпадает и с местом, это будет бык.
Например, загаданное число 1234, а предлагаемое число 1043. Следовательно, ответ будет 1 бык 2 коровы.
Кто быстрее угадает, тот и выиграл.

Игра запускается через main.py.
Ход игры путем взаимных вопросов и ответов регулируется BullsCows.py.
Для удобства и исключения ошибок при подготовки ответа число, загаданное игроком, сохраняется программой.
Вопросы и ответы генерируются в CompPlayer.py для игрока, который является компьютером, и в UserPlayer.py для пользователя.
Алгоритм поиска ответа записан в DecisionMaker.py.
Phrase.py предлагает перевод всех фраз на 4 языках.
Colors.py облегчает вывод сообщений в консоли разными цветами.

Analyser.py и GuessSelector.py разработаны для изучения ускорения поиска ответа после 1 серии вопрос-ответ.

Объяснение алгоритма поиска ответа в DecisionMaker.py.
Алгоритм должен найти число из всех возможных комбинаций, которое назовем поле поиска. Первоначально поле поиска включает 5040 чисел (размещение 4 элементов из
10). Любое число из первоначального поля поиска разбивает поле поиска на несколько корзин в зависимости от ответа на это число. Всего таких исходов 14, и они 
указаны в поле possible_answers_set = [0, 1, 2, 3, 4, 10, 11, 12, 13, 20, 21, 22, 30, 40] класса DecisionMaker. Например, любое число разбивает первоначальное поле поиска
на 14 корзин (Analyzer.get_example_initial_distribution(guess_example)):
[[1, 1440], [2, 1260], [11, 720], [10, 480], [0, 360], [3, 264], [12, 216], [20, 180], [21, 72], [30, 24], [4, 9], [13, 8], [22, 6], [40, 1]], т.е.
ответу 1 корова соответствует 1440 чисел, а например ответ 2 быка 2 коровы (22)
подходит для 6 чисел.
После каждой пары вопрос-ответ, поле поиска сужается (DecisionMaker: narrow_decisions_field()). 
Задача алгоритма DecisionMaker сделать этот путь короче. Для этого: 
- оставшееся поле поиска проверяется числом из первоначального поля и вычисляется, сколько чисел попадает в ту или иную корзину с определенным ответом (DecisionMaker: get_baskets_amounts()). Полученный массив сортируется в обратном порядке. 
- полученное распределение необходимо сравнить с остальными числами, чтобы выбрать менее глубокое распределение: минимальное из корзин с максимальным числом (DecisionMaker: get_all_baskets_amounts()).
- DecisionMaker: get_shallowest_baskets() выбирает распределение с минимальным количеством возможных ответов в корзинах (оптимальное распределение).
- DecisionMaker: get_optimal_list() выдает массив из чисел с оптимальным распределением.
- Ответ выбирается случайным образом из массива с оптимальным распределением, за исключением второго вопроса.
- Для поиска второй вопроса применена оптимизация, вычисленная с помощью Analyzer.build_first_level_optimization().
Поиск ответа с большим полем поиска занимает продолжительное время, но после первого ответа достаточно применить данные из оптимизации.
Например, после ответа 1 корова достаточно выбрать из первоначального распределения корзину с исходом 1 (1 корова).

PS
Возможно после второго ответа существует какая-то другая оптимизация. Попытка ее найти в Analyzer.build_second_level_optimization(), но она в разработке.
